# 常见编程概念

## 变量与可变性

- 变量默认是不可变的,Rust 编译器保证, 如果声明一个值不会变, 它就真的不会变
- 变量必须显式在变量名前添加 mut 声明为可变
- 变量 Shadowing
  - 通过定义一个与之前变量同名的新变量,第一个变量就被第二个 Shadowing(隐藏)了
  - Shadowing 和 mut 的区别
    - Shadowing 可以对这个值进行计算,而计算完之后的变量仍然是不可变的
    - Shadowing 实际上是创建了新变量,值的类型是可以改变的
- 常量与变量的区别
  - 常量使用 const 关键字
  - 常量必须注明值的类型
  - 不允许对常量使用 mut 关键字
  - 常量只能被设置为常量表达式,而不能是只能在运行时计算出的值
  - 常量的命名规则: 全大写单词通过下划线连接

## 数据类型

> Rust 数据类型可以划分为两类数据类型子集
>
> scalar 标量类型: 代表一个单独的值
>
> compound 复合类型: 可以将多个值组合成一个类型

### scalar 标量类型: 整型 / 浮点型 / 布尔类型 / 字符类型

- 整型: i8、i16、i32、i64、i128、isize、u8、u16、u32、u64、u128、usize

> 有符号整型范围为 -(2<sup>n - 1</sup>) 到 2<sup>n - 1</sup> - 1
>
> 无符号整型范围为 0 到 2<sup>n</sup> - 1
>
> isize 和 usize 依赖运行程序的计算机架构
>
> 需防止 [整形溢出](https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html#%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA) 问题

| 长度    | 有符号   | 无符号   |
|---------|---------|----------|
| 8-bit   | `i8`    | `u8`     |
| 16-bit  | `i16`   | `u16`    |
| 32-bit  | `i32`   | `u32`    |
| 64-bit  | `i64`   | `u64`    |
| 128-bit | `i128`  | `u128`   |
| arch    | `isize` | `usize`  |

- 浮点型: f32 和 f64(默认),在现代CPU中,二者速度相当,f64精度更高(双精度)
- 布尔类型: bool
- 字符类型: char 用 `单引号` 包裹,代表一个 Unicode 标量值,大小为 4 bytes

### compound 复合类型: 元组 / 数组

- 元组类型: tuple
  - 长度固定
  - 组成元素可以是不同类型(是将多个其他类型组合的主要方式)
  - 通过圆括号包裹,逗号分隔
  - 通过 `元组.索引` 方式访问
  - 可通过模式匹配来解构
  - () 单元值: 不带任何值的元组的特称,不返回任何值的表达式会隐式返回单元值
- 数组类型: array
  - 长度固定
  - 组成元素为同种类型
  - 存储在 stack 上
  - 通过 `数组[索引]` 方式访问
  - 访问超出长度会引发 panic

## 函数

- main 函数: 程序的默认入口
- 函数命名规则: snack case 风格(小写,通过下划线分割)
- 参数
  - parameter 形参: 定义函数的变量
  - arguments 实参: 调用函数的传参
- 语句和表达式: 函数由一系列语句和一个可选的表达式构成
  - 语句: 执行操作但不返回值的指令
  - 表达式: 计算并产生一个值,**表达式结尾没有分号!!!**
- 有返回值的函数需声明返回值类型

## 注释

- 代码注释: `// ...` || `/* ... */`
- 文档注释: `/// ...` || `/** ... */`
- 文档测试: `/// ``` ...`
- 文档注释中的代码跳转: /// `add_one`返回一个[`Option`]类型
- 包和模块注释: `//! ...` || `/*! ... */`

## 控制流 if / match / loop / while / for

- 条件判断的值或表达式必须是 bool 值
- 通过 continue / break 辅助控制流程
